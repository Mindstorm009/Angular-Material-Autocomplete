!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("@angular/common/http"),require("@angular/forms"),require("@angular/platform-browser"),require("@angular/material"),require("@angular/platform-browser/animations")):"function"==typeof define&&define.amd?define("@vguleaev/dynamic-autocomplete",["exports","@angular/core","@angular/common/http","@angular/forms","@angular/platform-browser","@angular/material","@angular/platform-browser/animations"],t):t((e.vguleaev=e.vguleaev||{},e.vguleaev["dynamic-autocomplete"]={}),e.ng.core,e.ng.common.http,e.ng.forms,e.ng.platformBrowser,e.ng.material,e.ng.platformBrowser.animations)}(this,function(exports,core,http,forms,platformBrowser,material,animations){"use strict";var AbstractValueAccessor=function(){function e(){this.disabled=!1,this._value="",this.onChange=function(e){},this.onTouched=function(){}}return Object.defineProperty(e.prototype,"value",{get:function(){return this._value},set:function(e){e!==this._value&&(this._value=e,this.onChange(e))},enumerable:!0,configurable:!0}),e.prototype.writeValue=function(e){this._value=e,this.onChange(e)},e.prototype.registerOnChange=function(e){this.onChange=e},e.prototype.registerOnTouched=function(e){this.onTouched=e},e.prototype.validate=function(e){return null},e.propDecorators={disabled:[{type:core.Input}],required:[{type:core.Input}],placeholder:[{type:core.Input}],formControlItem:[{type:core.Input}],formControlName:[{type:core.Input}]},e}(),extendStatics=function(e,t){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var o in t)t.hasOwnProperty(o)&&(e[o]=t[o])})(e,t)};function __extends(e,t){function o(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}var AutocompleteComponent=function(_super){function AutocompleteComponent(){var e=_super.call(this)||this;return e.name="",e.doPrefetch=!1,e.hasSearchButton=!1,e.hasProgressBar=!1,e.minChars=2,e.clearAfterSearch=!1,e.canCreateNew=!1,e.addNewText="Add new",e.focusOn=!1,e.validationErrors=[],e.filterCallback=function(e){return e},e.modelChange=new core.EventEmitter,e.optionSelected=new core.EventEmitter,e.createNew=new core.EventEmitter,e.query="",e.request=!1,e.requestsInQueue=0,e.placeholder=e.placeholder?e.placeholder:"Search",e}return __extends(AutocompleteComponent,_super),Object.defineProperty(AutocompleteComponent.prototype,"source",{set:function(e){this.isAutocompleteService(e)?this.service=e:e instanceof Array&&(this.storedItems=e.slice(0),this.saveReturnType(this.storedItems))},enumerable:!0,configurable:!0}),Object.defineProperty(AutocompleteComponent.prototype,"model",{get:function(){return this.currentModel},set:function(e){e!==this.currentModel&&(null!==(this.currentModel=e)&&this.returnType!==typeof e||this.modelChange.emit(e))},enumerable:!0,configurable:!0}),AutocompleteComponent.prototype.ngOnInit=function(){this.doPrefetch&&this.prefetch()},AutocompleteComponent.prototype.ngAfterViewInit=function(){var e=this;this.focusOn&&setTimeout(function(){e.autocompleteInput.nativeElement.focus()})},AutocompleteComponent.prototype.prefetch=function(){var t=this;if(!this.service)throw new Error("Service for prefetch is not defined in 'Source'");this.storedItems=[],this.noSuggestions=!1;var e=new http.HttpParams;this.serviceParams&&(e=this.serviceParams),this.service.fetch(e).then(function(e){t.storedItems=t.filterCallback(e),t.noSuggestions=0===e.length,t.saveReturnType(t.storedItems)})},AutocompleteComponent.prototype.fetch=function(e){var t=this;if(!this.service)throw new Error("Service for fetch is not defined in 'Source'");if(this.query=this.autocompleteInput.nativeElement.value,this.isQueryEmpty(this.query))this.autocompleteList=[];else if(e||this.query.length>=this.minChars){var o=new http.HttpParams;o=o.set("query",this.query),this.serviceParams&&(o=this.serviceParams.set("query",this.query)),this.noSuggestions=!1,this.requestsInQueue=this.requestsInQueue+1,this.service.fetch(o).then(function(e){t.requestsInQueue=t.requestsInQueue-1,t.autocompleteList=t.filterCallback(e),t.noSuggestions=0===e.length,t.saveReturnType(t.autocompleteList)})}},AutocompleteComponent.prototype.filterStoredItems=function(){var o=this;if(!this.displayItem&&!this.displayItemFn)throw new Error("You must provide displayItem or displayItemFn for local search.");this.query=this.autocompleteInput.nativeElement.value,this.query.length<this.minChars||(this.storedItems?(this.autocompleteList=this.storedItems.filter(function(e){if(!o.viewItem(e))throw new Error("String to evaluate in displayItem was provided wrong. Better use displayItemFn");var t=o.viewItem(e).toLowerCase();return o.displayItemFn&&(t=o.displayItemFn(e).toLowerCase()),-1<t.indexOf(o.query.toLowerCase())}),this.noSuggestions=0<this.query.length&&0===this.autocompleteList.length):(this.autocompleteList=[],this.noSuggestions=!1))},AutocompleteComponent.prototype.autocompleteSelected=function(e){this.query=this.autocompleteInput.nativeElement.value;var t=e.option.value;this.value=t,(this.model=t)&&this.optionSelected.emit(t),this.clearAfterSearch&&this.clearValue()},AutocompleteComponent.prototype.autocompleteDisplayFn=function(){var t=this;return this.displayItemFn?this.displayItemFn:function(e){return e?t.viewItem(e):e}},AutocompleteComponent.prototype.onKey=function(e){(e.keyCode<37||40<e.keyCode)&&(""===this.autocompleteInput.nativeElement.value&&this.clearValue(),this.onKeyCallback())},AutocompleteComponent.prototype.onKeyCallback=function(){this.doSearchViaService?this.fetch():this.filterStoredItems()},AutocompleteComponent.prototype.onBlur=function(e){this.searchButton&&""===this.autocompleteInput.nativeElement.value&&e.relatedTarget!==this.searchButton._elementRef.nativeElement&&(this.autocompleteInput.nativeElement.value=this.model?this.viewItem(this.model):"")},AutocompleteComponent.prototype.onFocus=function(e){this.doSearchViaService?this.fetch():this.filterStoredItems()},AutocompleteComponent.prototype.viewItem=function(item){return this.displayItemFn?this.displayItemFn(item):this.displayItem?eval(this.displayItem):item.name},AutocompleteComponent.prototype.clearValue=function(){this.formControlItem&&this.formControlItem.reset(),this.model=null,this.value=""},Object.defineProperty(AutocompleteComponent.prototype,"doSearchViaService",{get:function(){return this.service&&!this.doPrefetch},enumerable:!0,configurable:!0}),AutocompleteComponent.prototype.onCreateNew=function(){if(this.model){var e=this.returnType===typeof this.model?this.viewItem(this.model):this.model;this.autocompleteInput.nativeElement.value=e}this.createNew.emit(this.model)},AutocompleteComponent.prototype.isQueryEmpty=function(e){return e.length<=0},AutocompleteComponent.prototype.isAutocompleteService=function(e){return e&&"fetch"in e},AutocompleteComponent.prototype.saveReturnType=function(e){e&&0<e.length&&(this.returnType=typeof e[0])},AutocompleteComponent.decorators=[{type:core.Component,args:[{selector:"autocomplete",template:'<mat-form-field class="input-container">\n  <input matInput\n         *ngIf="formControlItem && formControlName"\n         [formControl]="formControlItem"\n         [required]="required"\n         [matAutocomplete]="autocomplete"\n         [placeholder]="placeholder"\n         (keyup)="onKey($event)"\n         (focus)="onFocus($event)"\n         (blur)="onBlur($event)"\n         #autocompleteInput\n  />\n  <input matInput\n         *ngIf="!formControlItem && !formControlName"\n         [name]="name"\n         [disabled]="disabled"\n         [required]="required"\n         [matAutocomplete]="autocomplete"\n         [placeholder]="placeholder"\n         (keyup)="onKey($event)"\n         (focus)="onFocus($event)"\n         (blur)="onBlur($event)"\n         [(ngModel)]="model"\n         #autocompleteInput\n  />\n  <button *ngIf="hasSearchButton" #searchButton mat-button matPrefix mat-icon-button aria-label="Search" (click)="fetch(true)" type="button">\n      <mat-icon class="search-icon">search</mat-icon>\n  </button>\n  <button *ngIf="model || value || query" mat-button matSuffix mat-icon-button aria-label="Clear" (click)="clearValue()" #clearButton type="button">\n    <mat-icon class="clear-icon">clear</mat-icon>\n  </button>\n  <mat-progress-bar mode="indeterminate" *ngIf="hasProgressBar && requestsInQueue > 0"></mat-progress-bar>\n  <mat-autocomplete #autocomplete="matAutocomplete"\n                    [displayWith]="autocompleteDisplayFn()"\n                    (optionSelected)="autocompleteSelected($event)">\n    <mat-option *ngFor="let item of autocompleteList" [value]="item">\n      <ng-template [ngIf]="displayTemplate">\n        <ng-container *ngTemplateOutlet="displayTemplate; context: {$implicit: item}"></ng-container>\n      </ng-template>\n      <span *ngIf="!displayTemplate">\n        {{viewItem(item)}}\n      </span>\n    </mat-option>\n    <mat-option *ngIf="query && noSuggestions" disabled>\n      <span>Sorry, no suggestions were found</span>\n    </mat-option>\n    <mat-option *ngIf="query && noSuggestions && canCreateNew" [value]="query" (click)="onCreateNew()">\n      <mat-icon class="add-icon">add</mat-icon> <span class="create-new"> {{addNewText}} </span>\n    </mat-option>\n  </mat-autocomplete>\n  <mat-error>\n    {{ validationErrors && validationErrors.length > 0 ? validationErrors[0] : \'\'}}\n  </mat-error>\n</mat-form-field>\n\n',styles:[".input-container{width:100%}.search-icon{font-size:24px}.mat-progress-bar{position:absolute}.create-new{color:#27ae60}.add-icon{position:relative;color:#27ae60}"],providers:[{provide:forms.NG_VALUE_ACCESSOR,useExisting:core.forwardRef(function(){return AutocompleteComponent}),multi:!0}]}]}],AutocompleteComponent.ctorParameters=function(){return[]},AutocompleteComponent.propDecorators={source:[{type:core.Input}],name:[{type:core.Input}],doPrefetch:[{type:core.Input}],displayItem:[{type:core.Input}],hasSearchButton:[{type:core.Input}],hasProgressBar:[{type:core.Input}],minChars:[{type:core.Input}],clearAfterSearch:[{type:core.Input}],canCreateNew:[{type:core.Input}],addNewText:[{type:core.Input}],focusOn:[{type:core.Input}],validationErrors:[{type:core.Input}],serviceParams:[{type:core.Input}],displayItemFn:[{type:core.Input}],displayTemplate:[{type:core.Input}],filterCallback:[{type:core.Input}],modelChange:[{type:core.Output}],optionSelected:[{type:core.Output}],createNew:[{type:core.Output}],autocompleteInput:[{type:core.ViewChild,args:["autocompleteInput"]}],searchButton:[{type:core.ViewChild,args:["searchButton"]}],clearButton:[{type:core.ViewChild,args:["clearButton"]}],autocomplete:[{type:core.ViewChild,args:["autocomplete"]}],model:[{type:core.Input}]},AutocompleteComponent}(AbstractValueAccessor),DynamicAutocompleteModule=function(){function e(){}return e.decorators=[{type:core.NgModule,args:[{imports:[platformBrowser.BrowserModule,forms.FormsModule,animations.BrowserAnimationsModule,forms.ReactiveFormsModule,material.MatInputModule,material.MatButtonModule,material.MatSelectModule,material.MatCardModule,material.MatAutocompleteModule,material.MatIconModule,material.MatProgressBarModule],declarations:[AutocompleteComponent],exports:[AutocompleteComponent]}]}],e}();exports.AbstractValueAccessor=AbstractValueAccessor,exports.DynamicAutocompleteModule=DynamicAutocompleteModule,exports.ɵa=AutocompleteComponent,Object.defineProperty(exports,"__esModule",{value:!0})});
//# sourceMappingURL=vguleaev-dynamic-autocomplete.umd.min.js.map